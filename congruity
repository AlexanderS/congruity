#!/usr/bin/python

# Copyright 2008 Stephen Warren
#
# This file is part of congruity.
#
# congruity is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# congruity is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with congruity.  If not, see <http://www.gnu.org/licenses/>.

from ctypes import *
import os
import os.path
import sys
import thread
import time
import traceback
import wx
import wx.lib.dialogs

import libconcord

version = "7+"

def counter():
    i=0
    while True:
        yield i
        i += 1

def program_callback_imp(count, current, total, context):
    if not context:
        return

    try:
        (f, fcontext) = context
        percent = (current * 100) / total
        f(False, percent, fcontext)
    except:
        print
        traceback.print_exc()

def exception_message():
    msg = ''
    if type(sys.exc_value) == libconcord.LibConcordException:
        try:
            msg += '%s\n    (libconcord function %s error %d)\n\n' % (
                sys.exc_value.result_str,
                sys.exc_value.func,
                sys.exc_value.result
            )
        except:
            pass
    msg += traceback.format_exc()
    return msg

def worker_body_connect(resources, on_progress, cb_context):
    program_callback = libconcord.callback_type(program_callback_imp)

    max_attempts = 60
    for attempt in range(max_attempts):
        on_progress(
            False,
            (attempt * 100) / max_attempts,
            cb_context
        )
        try:
            libconcord.init_concord()
            resources.SetConnected(True)
            libconcord.get_identity(
                program_callback,
                None
            )
            break
        except:
            if attempt == max_attempts - 1:
                raise
        time.sleep(1)
    on_progress(
        True,
        100,
        cb_context
    )

ALIGN_LBA = wx.ALIGN_LEFT | wx.ALIGN_BOTTOM          | wx.ALL
ALIGN_LCA = wx.ALIGN_LEFT | wx.ALIGN_CENTER_VERTICAL | wx.ALL 

class DecoratedGauge(object):
    def __init__(self, parent, caption, vpos):
        self.current_bitmap = parent.resources.icon_unstarted
        self.bitmap = wx.StaticBitmap(
            parent,
            -1,
            self.current_bitmap,
            None,
            parent.resources.iwh
        )
        self.text = wx.StaticText(parent, -1, caption)
        self.gauge = wx.Gauge(
            parent,
            -1,
            100,
            None,
            (250, parent.resources.iwh[1])
        )
        parent.sizer.Add(self.bitmap, (vpos, 0), (1, 1), ALIGN_LBA, 5)
        parent.sizer.Add(self.text,   (vpos, 1), (1, 1), ALIGN_LCA, 5)
        parent.sizer.Add(self.gauge,  (vpos, 2), (1, 1), ALIGN_LBA, 5)

    def SetBitmap(self, new_bitmap):
        if self.current_bitmap == new_bitmap:
            return
        self.current_bitmap = new_bitmap
        self.bitmap.SetBitmap(self.current_bitmap)

# FIXME: Why are we hard-coding this.
# Does the force the widget to be this wide when Fit()?
MSG_WRAP = 450

class MessagePanelBase(wx.Panel):
    def __init__(self, parent, resources, message):
        self.parent = parent
        self.resources = resources

        wx.Panel.__init__(self, parent)

        self.sizer = wx.BoxSizer(wx.VERTICAL)
        self.text_message = wx.StaticText(self, -1, message)
        self.text_message.Wrap(MSG_WRAP)
        self.sizer.Add(self.text_message, 0, wx.ALIGN_LEFT | wx.ALL, 5)
        self.SetSizerAndFit(self.sizer)

class WelcomePanel(MessagePanelBase):
    _msg_base = (
        "Welcome to congruity; a programming application " + 
        "for Logitech Harmony remote controls.\n\n" +
        "Operation type: %s\n\n"
    )

    _msg_please_connect_remote = (
        "Please ensure the remote control is connected " +
        "before proceeding.\n\n"
    )

    _msg_do_next = (
        "Click next to begin operation."
    )

    _msg_unreadable_file = (
        "The configuration file cannot be read. " +
        "Operation cannot continue."
    )

    _msg_unsupported_filetype = (
        "This kind of configuration file is not currently supported. " +
        "Operation cannot continue."
    )

    _msg_parsing = "Parsing..."

    _msg_unknown = "Unknown"

    def __init__(self, parent, resources):
        MessagePanelBase.__init__(
            self,
            parent,
            resources,
            self._msg_base % self._msg_parsing
        )

        self.next = None

    def _WorkerFunction(self):
        try:
            self.next = self.resources.page_connect

            xml = POINTER(c_ubyte)()
            xml_size = c_uint()
            libconcord.read_file(
                self.resources.ezhex_filename,
                byref(xml),
                byref(xml_size)
            )
            self.resources.SetXmlData(xml, xml_size)

            type = c_int()
            libconcord.identify_file(xml, xml_size, byref(type))

            (next_page, type_text) = {
                libconcord.LC_FILE_TYPE_CONNECTIVITY:
                    (
                        self.resources.page_check_connectivity,
                        "Connectivity Check"
                    ),
                libconcord.LC_FILE_TYPE_CONFIGURATION:
                    (
                        self.resources.page_write_configuration,
                        "Update Configuration"
                    ),
                libconcord.LC_FILE_TYPE_FIRMWARE:
                    (
                        self.resources.page_update_firmware,
                        "Update Firmware"
                    )
            }.get(type.value, (None, None))

            if next_page:
                wx.CallAfter(self._OnStatusOk, next_page, type_text)
                return

            wx.CallAfter(
                self._OnStatusFailure,
                self._msg_unsupported_filetype,
                None
            )
            return
        except:
            wx.CallAfter(
                self._OnStatusFailure,
                self._msg_unreadable_file,
                exception_message()
            )

    def _OnStatusOk(self, next_page, type_text):
        self.resources.page_connect.SetNext(next_page)
        self._SetLabelReenableButtons(type_text, True)

    def _OnStatusFailure(self, failure_msg, details):
        self.resources.page_failure.SetMessages(
            failure_msg,
            details
        )
        self.next = self.resources.page_failure
        self._SetLabelReenableButtons(self._msg_unknown, False)

    def _SetLabelReenableButtons(self, file_type, ok):
        msg = (self._msg_base % file_type)
        if ok:
            msg += self._msg_please_connect_remote
        msg += self._msg_do_next
        self.text_message.SetLabel(msg)           
        self.text_message.Wrap(MSG_WRAP)
        self.parent.ReenableCancel()
        self.parent.ReenableNext()

    def OnActivated(self):
        thread.start_new_thread(self._WorkerFunction, ())

    def OnCancel(self):
        os._exit(1)

    def GetTitle(self):
        return "Welcome"

    def IsTerminal(self):
        return False

    def IsNextInitiallyDisabled(self):
        return True

    def IsCancelInitiallyDisabled(self):
        return True

    def GetNext(self):
        return self.next

class GbsPanelBase(wx.Panel):
    def __init__(self, parent, resources):
        self.parent = parent
        self.resources = resources

        wx.Panel.__init__(self, parent)

        self.sizer = wx.GridBagSizer(5, 5)

        self._AddWidgets()

        self.sizer.AddGrowableCol(2)

        self.SetSizerAndFit(self.sizer)

        self.last_updated_dg = None

    def _AddWidgets(self):
        pass

    def _DgStart(self, dg):
        wx.CallAfter(self._OnProgressGauge, False, 0, dg)

    def _DgUpdate(self, is_done, percent, dg):
        wx.CallAfter(self._OnProgressGauge, is_done, percent, dg)

    def _DgEnd(self, dg):
        wx.CallAfter(self._OnProgressGauge, True, 100, dg)

    def _OnStatusOk(self):
        self.parent.ReenableCancel()
        self.parent.ReenableNext()

    def _OnStatusFailure(self, failure_msg, details):
        self.resources.page_failure.SetMessages(
            failure_msg,
            details
        )
        if self.last_updated_dg:
            bitmap = self.last_updated_dg
            bitmap.SetBitmap(self.resources.icon_failed)
        self.parent.ReenableCancel()
        self.parent.ReenableNext()

    def _OnProgressGauge(self, is_done, percent, dg):
        if is_done:
            new_bitmap = self.resources.icon_complete
        else:
            new_bitmap = self.resources.icon_in_progress
        dg.SetBitmap(new_bitmap)
        dg.gauge.SetValue(percent)
        self.last_updated_dg = dg

class ConnectPanel(GbsPanelBase):
    def __init__(self, parent, resources):
        self.next = None
        self.cancel_requested = False
        GbsPanelBase.__init__(self, parent, resources)

    def _AddWidgets(self):
        # FIXME: Should probably add instructions saying
        # "connect your remote now!" here
        self.dg_connect = DecoratedGauge(self, "Detect Remote", 0)

    def _WorkerFunction(self):
        try:
            worker_body_connect(
                self.resources,
                self._DgUpdate,
                self.dg_connect
            )
            wx.CallAfter(self._OnStatusOk)
            return
        except:
            wx.CallAfter(
                self._OnStatusFailure,
                "No remote found",
                exception_message()
            )

    def _OnStatusFailure(self, failure_msg, details):
        self.SetNext(self.resources.page_failure)
        GbsPanelBase._OnStatusFailure(self, failure_msg, details)

    def SetNext(self, next):
        self.next = next

    def OnActivated(self):
        thread.start_new_thread(self._WorkerFunction, ())

    def OnCancel(self):
        os._exit(1)

    def GetTitle(self):
        return "Connecting"

    def IsTerminal(self):
        return False

    def IsNextInitiallyDisabled(self):
        return True

    def IsCancelInitiallyDisabled(self):
        return False

    def GetNext(self):
        return self.next

class ProgramRemotePanelBase(GbsPanelBase):
    def __init__(self, parent, resources, file_type):
        self.file_type = file_type
        self.next = None
        GbsPanelBase.__init__(self, parent, resources)

    def _WorkerFunction(self):
        try:
            try:
                self._WorkerFunctionBody()
                wx.CallAfter(self._OnStatusOk)
                return
            except:
                wx.CallAfter(
                    self._OnStatusFailure,
                    "Operation Failed",
                    exception_message()
                )
        finally:
            try:
                if self.resources.connected:
                    self.resources.SetConnected(False)
                    libconcord.deinit_concord()
            except:
                pass

    def _OnStatusOk(self):
        self.next = self.resources.page_success
        GbsPanelBase._OnStatusOk(self)

    def _OnStatusFailure(self, failure_msg, details):
        self.next = self.resources.page_failure
        GbsPanelBase._OnStatusFailure(self, failure_msg, details)

    def OnActivated(self):
        thread.start_new_thread(self._WorkerFunction, ())

    def OnCancel(self):
        # FIXME: Do something here, like display a "no!" dialog.
        # We don't just quit, so programming isn't aborted part-way-through
        # which could leave the remote in a bad state,
        pass

    def IsTerminal(self):
        return False

    def IsNextInitiallyDisabled(self):
        return True

    def IsCancelInitiallyDisabled(self):
        return True

    def GetNext(self):
        return self.next

class CheckConnectivityPanel(ProgramRemotePanelBase):
    def __init__(self, parent, resources):
        ProgramRemotePanelBase.__init__(
            self,
            parent,
            resources,
            libconcord.LC_FILE_TYPE_CONNECTIVITY
        )

    def _AddWidgets(self):
        vpos = counter()
        self.dg_notify_website = DecoratedGauge(self, "Notify Website", vpos.next())

    def _WorkerFunctionBody(self):
        self._DgUpdate(
            False,
            0,
            self.dg_notify_website
        )
        libconcord.post_connect_test_success(
            self.resources.xml,
            self.resources.xml_size
        )
        self._DgUpdate(
            True,
            100,
            self.dg_notify_website
        )

    def GetTitle(self):
        return "Checking Connectivity"

class WriteConfigurationPanel(ProgramRemotePanelBase):
    def __init__(self, parent, resources):
        ProgramRemotePanelBase.__init__(
            self,
            parent,
            resources,
            libconcord.LC_FILE_TYPE_CONFIGURATION
        )

    def _AddWidgets(self):
        vpos = counter()
        self.dg_check_website = DecoratedGauge(self, "Check Website", vpos.next())
        self.dg_prepare = DecoratedGauge(self, "Prepare Remote", vpos.next())
        self.dg_erase = DecoratedGauge(self, "Erase Flash", vpos.next())
        self.dg_write = DecoratedGauge(self, "Write Configuration", vpos.next())
        self.dg_verify = DecoratedGauge(self, "Verify Upgrade", vpos.next())
        self.dg_reconnect = DecoratedGauge(self, "Reconnect to Remote", vpos.next())
        self.dg_set_time = DecoratedGauge(self, "Set Time", vpos.next())
        self.dg_notify_website = DecoratedGauge(self, "Notify Website", vpos.next())

    def _WorkerFunctionBody(self):
        program_callback = libconcord.callback_type(program_callback_imp)

        self._DgStart(self.dg_check_website)
        libconcord.post_preconfig(self.resources.xml, self.resources.xml_size)
        self._DgEnd(self.dg_check_website)

        self._DgStart(self.dg_prepare)
        bin_data = POINTER(c_ubyte)()
        bin_size = c_uint()
        libconcord.find_config_binary(
            self.resources.xml,
            self.resources.xml_size,
            byref(bin_data),
            byref(bin_size)
        )
        self._DgUpdate(False, 50, self.dg_prepare)
        libconcord.invalidate_flash()
        self._DgEnd(self.dg_prepare)

        self._DgStart(self.dg_erase)
        libconcord.erase_config(
            bin_size,
            program_callback,
            py_object((self._DgUpdate, self.dg_erase))
        )
        self._DgEnd(self.dg_erase)

        self._DgStart(self.dg_write)
        libconcord.write_config_to_remote(
            bin_data,
            bin_size,
            program_callback,
            py_object((self._DgUpdate, self.dg_write))
        )
        self._DgEnd(self.dg_write)

        self._DgStart(self.dg_verify)
        libconcord.verify_remote_config(
            bin_data,
            bin_size,
            program_callback,
            py_object((self._DgUpdate, self.dg_verify))
        )
        self._DgEnd(self.dg_verify)

        self._DgStart(self.dg_reconnect)
        libconcord.reset_remote()
        worker_body_connect(self.resources, self._DgUpdate, self.dg_reconnect)

        self._DgStart(self.dg_set_time)
        libconcord.set_time()
        self._DgEnd(self.dg_set_time)

        self._DgStart(self.dg_notify_website)
        libconcord.post_postconfig(self.resources.xml, self.resources.xml_size)
        self._DgEnd(self.dg_notify_website)

    def GetTitle(self):
        return "Updating Configuration"

class UpdateFirmwarePanel(ProgramRemotePanelBase):
    def __init__(self, parent, resources):
        ProgramRemotePanelBase.__init__(
            self,
            parent,
            resources,
            libconcord.LC_FILE_TYPE_FIRMWARE
        )

    def _AddWidgets(self):
        vpos = counter()
        self.dg_prepare = DecoratedGauge(self, "Prepare Remote", vpos.next())
        self.dg_erase = DecoratedGauge(self, "Erase Flash", vpos.next())
        self.dg_write = DecoratedGauge(self, "Write Firmware", vpos.next())
        self.dg_finalize = DecoratedGauge(self, "Finalize Programming", vpos.next())
        self.dg_reconnect = DecoratedGauge(self, "Reconnect to Remote", vpos.next())
        self.dg_set_time = DecoratedGauge(self, "Set Time", vpos.next())
        self.dg_notify_website = DecoratedGauge(self, "Notify Website", vpos.next())

    def _WorkerFunctionBody(self):
        program_callback = libconcord.callback_type(program_callback_imp)

        self._DgStart(self.dg_prepare)

        # is_fw_update_supported returns error code; 0 OK, otherwise failure
        # FIXME: Should probably determine this in OnActivated, and
        # hide dg_finalize if it isn't relevant
        if libconcord.is_fw_update_supported(0) == 0:
            is_direct = False
        elif libconcord.is_fw_update_supported(1) == 0:
            is_direct = True
        else:
            raise Exception('Firmware update not supported on this remote.')

        self._DgUpdate(False, 25, self.dg_prepare)

        bin_data = POINTER(c_ubyte)()
        bin_size = c_uint()
        libconcord.extract_firmware_binary(
            self.resources.xml,
            self.resources.xml_size,
            byref(bin_data),
            byref(bin_size)
        )

        self._DgUpdate(False, 50, self.dg_prepare)

        if not is_direct:
            libconcord.prep_firmware()

        self._DgUpdate(False, 75, self.dg_prepare)

        libconcord.invalidate_flash()

        self._DgEnd(self.dg_prepare)

        self._DgStart(self.dg_erase)
        libconcord.erase_firmware(
            is_direct,
            program_callback,
            py_object((self._DgUpdate, self.dg_erase))
        )
        self._DgEnd(self.dg_erase)

        self._DgStart(self.dg_write)
        libconcord.write_firmware_to_remote(
            bin_data,
            bin_size,
            c_int(is_direct and 1 or 0),
            program_callback,
            py_object((self._DgUpdate, self.dg_write))
        )
        self._DgEnd(self.dg_write)

        self._DgStart(self.dg_finalize)
        if not is_direct:
            libconcord.finish_firmware()
        self._DgEnd(self.dg_finalize)

        self._DgStart(self.dg_reconnect)
        libconcord.reset_remote()
        worker_body_connect(self.resources, self._DgUpdate, self.dg_reconnect)

        self._DgStart(self.dg_set_time)
        libconcord.set_time()
        self._DgEnd(self.dg_set_time)

        self._DgStart(self.dg_notify_website)
        libconcord.post_postfirmware(self.resources.xml, self.resources.xml_size)
        self._DgEnd(self.dg_notify_website)

    def GetTitle(self):
        return "Updating Firmware"

class SuccessPanel(MessagePanelBase):
    def __init__(self, parent, resources):
        MessagePanelBase.__init__(
            self,
            parent,
            resources,
            "Programming has completed successfully."
        )

    def OnActivated(self):
        pass

    def OnCancel(self):
        os._exit(0)

    def GetTitle(self):
        return "Success"

    def IsTerminal(self):
        return True

    def GetExitCode(self):
        return 0

    def IsNextInitiallyDisabled(self):
        return False

    def IsCancelInitiallyDisabled(self):
        return True

class FailurePanel(wx.Panel):
    def __init__(self, parent, resources):
        self.parent = parent
        self.resources = resources

        wx.Panel.__init__(self, parent)

        self.sizer = wx.BoxSizer(wx.VERTICAL)
        self.text_message = wx.StaticText(
            self,
            -1,
            "Programming failed; see below for details"
        )
        self.text_message.Wrap(450)
        self.sizer.Add(self.text_message, 0, wx.ALIGN_LEFT | wx.ALL, 5)
        self.btn_details = wx.Button(self, -1, "&Details...")
        self.Bind(wx.EVT_BUTTON, self.OnShowLogText, self.btn_details)
        self.sizer.Add(self.btn_details, 0, wx.ALIGN_LEFT | wx.ALL, 5)
        self.SetSizerAndFit(self.sizer)
        self.log_text = ''

    def SetMessages(self, message, traceback):
        msg = message
        if traceback:
            msg += "\n\nSee below for details."
        else:
            self.btn_details.Hide()
        self.text_message.SetLabel(msg)
        self.text_message.Wrap(MSG_WRAP)
        self.log_text = traceback

    def OnShowLogText(self, event):
        size = self.parent.GetClientSizeTuple()
        size = (size[0] * 90 / 100, size[1] * 90 / 100)
        wx.lib.dialogs.ScrolledMessageDialog(
            self,
            self.log_text,
            "Error Log",
            (-1, -1),
            size
        ).ShowModal()
        self.parent.ReenableNext()

    def OnActivated(self):
        self.btn_details.SetFocus()

    def OnCancel(self):
        os._exit(1)

    def GetTitle(self):
        return "Failure"

    def IsTerminal(self):
        return True

    def GetExitCode(self):
        return 1

    def IsNextInitiallyDisabled(self):
        return False

    def IsCancelInitiallyDisabled(self):
        return True

class Wizard(wx.Dialog):
    def __init__(self, resources):
        wx.Dialog.__init__(self, None, -1, 'Congruity version ' + version)

        sizer_main = wx.BoxSizer(wx.VERTICAL)

        sizer_top = wx.BoxSizer(wx.HORIZONTAL)
        bitmap = wx.StaticBitmap(self, -1, resources.img_remote)
        sizer_top.Add(bitmap, 0, wx.EXPAND | wx.ALL, 5)

        self.sizer_top_right = wx.BoxSizer(wx.VERTICAL)
        self.title = wx.StaticText(self, -1, "Title")
        font = wx.Font(18, wx.SWISS, wx.NORMAL, wx.BOLD)
        self.title.SetFont(font)
        self.sizer_top_right.Add(self.title, 0, wx.EXPAND)
        divider_top_right = wx.StaticLine(self, -1, None, None, wx.LI_HORIZONTAL)
        self.sizer_top_right.Add(divider_top_right, 0, wx.EXPAND)

        sizer_top.Add(self.sizer_top_right, 1, wx.EXPAND | wx.ALL, 5)
        sizer_main.Add(sizer_top, 1, wx.EXPAND | wx.ALL, 5)

        divider_main = wx.StaticLine(self, -1, None, None, wx.LI_HORIZONTAL)
        sizer_main.Add(divider_main, 0, wx.EXPAND | wx.ALL, 5)

        sizer_buttons = wx.BoxSizer(wx.HORIZONTAL)
        panel_btn_dummy = wx.Panel(self)
        sizer_buttons.Add(panel_btn_dummy, 1, wx.EXPAND | wx.ALL, 5)
        self.btn_next = wx.Button(self, -1, "&Next >")
        self.Bind(wx.EVT_BUTTON, self._OnNext, self.btn_next)
        sizer_buttons.Add(self.btn_next, 0, wx.EXPAND | wx.ALL, 5)
        self.btn_cancel = wx.Button(self, -1, "&Cancel")
        self.Bind(wx.EVT_BUTTON, self._OnCancel, self.btn_cancel)
        self.Bind(wx.EVT_CLOSE, self._OnCancel)
        sizer_buttons.Add(self.btn_cancel, 0, wx.EXPAND | wx.ALL, 5)
        sizer_main.Add(sizer_buttons, 0, wx.EXPAND | wx.ALL, 5)

        self.SetSizerAndFit(sizer_main)

        self.cur_page = None

    def SetPages(self, pages):
        def tuple_max(a, b):
            return (max(a[0], b[0]), max(a[1], b[1]))

        self.pages = pages

        for page in self.pages:
            page.Hide()

        self.size_wiz = self.GetSizeTuple()
        for page in self.pages:
            page.Show()
            self.sizer_top_right.Add(page, 1, wx.EXPAND)
            self.Fit()
            size_page = self.GetSizeTuple()
            self.size_wiz = tuple_max(self.size_wiz, size_page)
            page.Hide()
            self.sizer_top_right.Remove(page)

        self.SetSize(self.size_wiz)

    def SetInitialPage(self, page):
        if self.cur_page:
            raise Exception("Current page already set")
        self._SetPage(page)

    def _ReenableButton(self, button):
        button.Enable(True)

        mouse_pos = self.ScreenToClient(wx.GetMousePosition())
        if button.GetRect().Contains(mouse_pos):
            self.WarpPointer(0, 0)
            self.WarpPointer(mouse_pos.x, mouse_pos.y)

        button.SetFocus()

    def ReenableNext(self):
        self._ReenableButton(self.btn_next)

    def ReenableCancel(self):
        self._ReenableButton(self.btn_cancel)

    def _OnNext(self, event):
        if self.cur_page.IsTerminal():
            os._exit(self.cur_page.GetExitCode())
        next_page = self.cur_page.GetNext()
        self._SetPage(next_page)

    def _OnCancel(self, event):
        self.cur_page.OnCancel()

    def _SetPage(self, page):
        if not page in self.pages:
            raise Exception("Invalid page")

        if self.cur_page:
            self.cur_page.Hide()
            self.sizer_top_right.Remove(self.cur_page)

        self.cur_page = page

        self.cur_page.Show()
        self.sizer_top_right.Add(self.cur_page, 1, wx.EXPAND)

        self.title.SetLabel(self.cur_page.GetTitle())

        self.Layout()

        is_terminal = self.cur_page.IsTerminal()
        if is_terminal:
            self.btn_next.SetLabel("&Finish")
        else:
            self.btn_next.SetLabel("&Next >")

        self.btn_next.Enable(not self.cur_page.IsNextInitiallyDisabled())
        self.btn_cancel.Enable(
            (not is_terminal)
            and
            (not self.cur_page.IsCancelInitiallyDisabled())
        )
        self.btn_next.SetFocus()

        self.cur_page.OnActivated()

class Resources(object):
    def __init__(self, appdir):
        self.appdir = appdir

        self.ezhex_filename = None
        self.xml = None
        self.xml_size = None
        self.connected = False

    def LoadImages(self):
        def load(filename, appdir = self.appdir):
            dirs = ['/usr/share/congruity', appdir, '.']
            for dir in dirs:
                fpath = os.path.join(dir, filename)
                if not os.path.isfile(fpath):
                    continue
                return wx.Image(fpath, wx.BITMAP_TYPE_PNG).ConvertToBitmap()
            raise Exception("Can't load " + filename)

        self.img_remote       = load("remote.png")
        self.icon_unstarted   = load("icon-unstarted.png")
        self.icon_in_progress = load("icon-in-progress.png")
        self.icon_complete    = load("icon-complete.png")
        self.icon_failed      = load("icon-failed.png")

        iw = max(
            self.icon_in_progress.GetWidth(),
            self.icon_complete.GetWidth(),
            self.icon_failed.GetWidth()
        )
        ih = max(
            self.icon_in_progress.GetHeight(),
            self.icon_complete.GetHeight(),
            self.icon_failed.GetHeight()
        )
        self.iwh = (iw, ih)

    def CreatePages(self, wizard):
        self.page_welcome = WelcomePanel(wizard, self)
        self.page_connect = ConnectPanel(wizard, self)
        self.page_check_connectivity = CheckConnectivityPanel(wizard, self)
        self.page_write_configuration = WriteConfigurationPanel(wizard, self)
        self.page_update_firmware = UpdateFirmwarePanel(wizard, self)
        self.page_success = SuccessPanel(wizard, self)
        self.page_failure = FailurePanel(wizard, self)

    def SetEzHexFilename(self, ezhex_filename):
        self.ezhex_filename = ezhex_filename

    def SetXmlData(self, xml, xml_size):
        self.xml = xml
        self.xml_size = xml_size

    def SetConnected(self, connected):
        self.connected = connected

def main(argv):
    app = argv.pop(0)
    appdir = os.path.dirname(app)

    # FIXME: Convert errors here into a jump to the failure page,
    # so that there's alway GUI feedback on status. If congruity is
    # run from a GUI app (e.g. browser like Firefox), there may be no
    # terminal to report these errors on stderr...
    while len(argv) and argv[0].startswith('-'):
        arg = argv.pop(0)
        if arg == '--version':
            print version
            sys.exit(0)
        else:
            print >>sys.stderr, "ERROR: Option '%s' not recognized" % arg
            sys.exit(0)
    if len(argv) != 1:
        print >>sys.stderr, "ERROR: Precisely one filename argument is required"
        sys.exit(0)
    ezhex_filename = argv.pop(0)

    app = wx.PySimpleApp()
    wx.InitAllImageHandlers()

    resources = Resources(appdir)
    resources.LoadImages()
    resources.SetEzHexFilename(ezhex_filename)

    wizard = Wizard(resources)

    resources.CreatePages(wizard)
    wizard.SetPages([
        resources.page_welcome,
        resources.page_connect,
        resources.page_check_connectivity,
        resources.page_write_configuration,
        resources.page_update_firmware,
        resources.page_success,
        resources.page_failure
    ])
    wizard.SetInitialPage(resources.page_welcome)

    wizard.Show()

    app.MainLoop()

if __name__ == "__main__":
    main(sys.argv)

